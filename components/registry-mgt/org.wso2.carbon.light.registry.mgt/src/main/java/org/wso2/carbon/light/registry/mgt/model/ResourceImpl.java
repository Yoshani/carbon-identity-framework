/*
 * Copyright (c) 2008, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.wso2.carbon.light.registry.mgt.model;

import org.wso2.carbon.light.registry.mgt.LightRegistryException;
import org.wso2.carbon.light.registry.mgt.constants.LightRegistryConstants;
import org.wso2.carbon.light.registry.mgt.utils.RegistryUtils;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Properties;

/**
 * Represents any file or collection stored in the registry. It encapsulates both the content of the
 * entity and its metadata. In addition to files and collections, instances of Resource are used to
 * represent results of runtime queries. In such scenarios, comments, tags, ratings as well as
 * collections of comments, etc. are also represented by Resource objects.
 * <p/>
 * Each resource instance contains a unique path within a Registry instance.
 * <p/>
 * <strong>Handling content</strong>
 * <p/>
 * Contents of resource can be set either as an input stream or an object. If an input stream is
 * set, a unique file based content will be created for the given input stream. If an object of
 * type byte[] or String is set, an in-memory input stream will be created from it and then a
 * unique file based input stream is created. If an object of any other type is set, there should be
 * a handler to convert it to an input stream before reaching the repository.
 * <p/>
 * When a resource is retrieved from the database layer, its content is not retrieved from the
 * database. Instead, UUID referring to the database content is stored in dbBasedContentID. When the
 * content is first accessed, a file based input stream is created from the database content and
 * fileBasedContentID is set (fileBasedContentID = dbBasedContentID).
 */
public class ResourceImpl implements Resource {

    /**
     * UUID to identify the resource. currently this is same as the path
     */
    protected String id;

    /**
     * Username of the user who added the resource to the registry.
     */
    protected String authorUserName;

    /**
     * Time at which the resource is first added to the registry.
     */
    protected long createdTime;

    /**
     * Username of the user who modified the resource most recently.
     */
    protected String lastUpdaterUserName;

    /**
     * Time at which the resource modified most recently.
     */
    protected long lastModified;

    /**
     * Description about the resource. This may contain any text including HTML fragments.
     */
    protected String description;

    /**
     * Unique path of the resource within the registry. This is generated by appending all ascendant
     * paths to the resource name separated by "/". For example assume that the resource name is
     * "users.xml". config.xml if inside the collection named "config". config collection is inside
     * the root level collection named "servers". Then the path of the resource is
     * /servers/config/users.xml.
     */
    protected String path;

    /**
     * Media type of the resource. Each resource can have a media type associated with it. This can
     * be either a standard MIME media type or a custom media type defined by the users of the
     * registry. Media type is used to activate media type handlers defined in the registry. Thus,
     * by defining a media type for a resource and by registering a media type handler to handle
     * that media type, it is possible to apply special processing for resources.
     */
    protected String mediaType;

    /**
     * Path of the parent collection of the resource. If the resource path is
     * /servers/config/users.xml, parent path is /servers/config.
     */
    protected String parentPath;

    /**
     * Determines whether the resource is subjected to changes, which causes it to create a new
     * version. If true, a new version will be created upon adding the resource to the repository.
     */
    protected boolean versionableChange;

    /**
     * Properties associated with the resource. A resource can contain zero or more properties,
     * where each property is a name->value pair. Both name and the value should be strings.
     */
    protected Properties properties = new Properties();

    /**
     * UUID of the content stored in the database. This ID is set when a resource is retrieved from
     * the database. Upon the first getContentStream() call, a file based content will be created
     * from this database based content and file based content ID will be set.
     */
    protected int dbBasedContentID = -1;

    /**
     * Content of the resource. Object and the type stored in this field depends on the resource
     * type. If the resource is a file with no special media type handling, this contains an array
     * of bytes (byte[]) containing the raw bytes of the file. If the resource is a collection, this
     * contains a String[] containing the paths of child resources. If the resource is processed by
     * a media type handler, it is up to the media type handler to set a content. In that case
     * content can be anything ranging from String to custom type. Therefore, clients of the API
     * should be aware of the media type and the content for that media type.
     */
    protected Object content;

    /**
     * tenant id resource belongs to
     */
    protected int tenantId = -1;

    /**
     * path id, if collection - id of the path of the collection if non-collection - id of the path
     * of the non-collection
     */
    protected int pathID;

    /**
     * the name of the resource if collection - NULL non-collection - the name of the resource..
     */
    protected String name;

    /*
     * Defines the UUID of the resource
     */
    protected String uuid;

    /**
     * Default constructor for the resource. Creates an empty resource.
     */

    public ResourceImpl() {

        this.id = null;
    }

    /**
     * Construct a resource with given path and resource data object.
     *
     * @param path     the path of the resource.
     * @param resource the resource data object.
     */
    public ResourceImpl(String path, Resource resource) {

        this.id = path;
        this.authorUserName = resource.getAuthorUserName();
        this.createdTime = resource.getCreatedTime().getTime();
        this.lastUpdaterUserName = resource.getLastUpdaterUserName();
        this.lastModified = resource.getLastModified().getTime();
        this.description = resource.getDescription();
        this.path = path;
        this.mediaType = resource.getMediaType();
        this.parentPath = RegistryUtils.getParentPath(path);
        this.versionableChange = true;
        this.dbBasedContentID = ((ResourceImpl) resource).getDbBasedContentID();
        this.content = null;
        this.pathID = ((ResourceImpl) resource).getPathID();
        this.name = ((ResourceImpl) resource).getName();
        this.uuid = ((ResourceImpl) resource).getUUID();
    }

    /**
     * A copy constructor used to create a shallow-copy of this resource.
     *
     * @param resource the resource of which the copy is created.
     */
    public ResourceImpl(ResourceImpl resource) {

        this.id = resource.id;
        this.authorUserName = resource.authorUserName;
        this.createdTime = resource.createdTime;
        this.lastUpdaterUserName = resource.lastUpdaterUserName;
        this.lastModified = resource.lastModified;
        this.description = resource.description;
        this.path = resource.path;
        this.mediaType = resource.mediaType;
        this.parentPath = resource.parentPath;
        this.versionableChange = resource.versionableChange;
        this.tenantId = resource.tenantId;
        this.pathID = resource.pathID;
        this.name = resource.name;
        this.properties.putAll(resource.properties);
        this.dbBasedContentID = resource.dbBasedContentID;
        this.content = resource.content;
        this.uuid = resource.getUUID();
    }

    /**
     * Method to get the UUID
     *
     * @return the UUID of the resource
     */
    public String getUUID() {

        return uuid;
    }

    /**
     * Method to set the UUID of the resource
     *
     * @param uuid the UUID of the resource
     */
    public void setUUID(String uuid) {

        this.uuid = uuid;
    }

    /**
     * Method to set the tenant id associated with the resource.
     *
     * @param tenantId the tenant id.
     */
    public void setTenantId(int tenantId) {

        this.tenantId = tenantId;
    }

    /**
     * Method to get the tenant id associated with the resource.
     */
    public int getTenantId() {

        return tenantId;
    }

    /**
     * The Resource ID, In the default implementation this returns the path.
     *
     * @return the resource id
     */
    public String getId() {

        return path;
    }

    /**
     * Method to set the resource id, currently it will just set the path.
     *
     * @param id the path
     */
    public void setId(String id) {

        this.path = id;
    }

    /**
     * Method to get the author username.
     *
     * @return the author username.
     */
    public String getAuthorUserName() {

        return authorUserName;
    }

    /**
     * Method to set the author username.
     *
     * @param authorUserName the author username.
     */
    public void setAuthorUserName(String authorUserName) {

        this.authorUserName = authorUserName;
    }

    /**
     * Method to get the created time.
     *
     * @return the created time.
     */
    public Date getCreatedTime() {

        return new Date(createdTime);
    }

    /**
     * Method to set the created time.
     *
     * @param createdTime the created time.
     */
    public void setCreatedTime(Date createdTime) {

        this.createdTime = createdTime.getTime();
    }

    /**
     * Method to get the created time.
     *
     * @return the created time
     */
    public Date getLastModified() {

        return new Date(lastModified);
    }

    /**
     * Method to set the last modified date.
     *
     * @param lastModified the last modified date.
     */
    public void setLastModified(Date lastModified) {

        this.lastModified = lastModified.getTime();
    }

    /**
     * Method to get the description.
     *
     * @return the description.
     */
    public String getDescription() {

        return description;
    }

    /**
     * Method to set the description.
     *
     * @param description the description.
     */
    public void setDescription(String description) {

        this.description = description;
        versionableChange = true;
    }

    /**
     * Method to get the path. the unique identifier of the resources in the present state.
     *
     * @return the path.
     */
    public String getPath() {

        return path;
    }

    /**
     * Method to get the path. the unique identifier of the resources in the present state.
     *
     * @param path the path.
     */
    public void setPath(String path) {

        this.path = path == null ? null : preparePath(path);
    }

    /**
     * Method to get the media type.
     *
     * @return the media type.
     */
    public String getMediaType() {

        return mediaType;
    }

    /**
     * Method to set the media type.
     *
     * @param mediaType the media type.
     */
    public void setMediaType(String mediaType) {

        if (mediaType != null) {
            mediaType = (mediaType.trim().equals("")) ? null : mediaType;
        }
        this.mediaType = mediaType;
        versionableChange = true;
    }

    /**
     * Method to get the parent path.
     *
     * @return the parent path.
     */
    public String getParentPath() {

        if (parentPath != null) {
            return parentPath;
        }
        if ((path == null) || path.length() == 1) {
            return null;
        }
        int i = path.lastIndexOf('/');
        return path.substring(0, i);
    }

    /**
     * Method to set the parent path.
     *
     * @param parentPath the parent path.
     */
    public void setParentPath(String parentPath) {

        this.parentPath = parentPath;
    }

    /**
     * Get the property value for the given key, if there are multiple value for that key, it will
     * return the first value.
     *
     * @param key the property key.
     * @return the property value.
     */
    public String getProperty(String key) {

        List<String> propValues = getPropertyValues(key);
        if (propValues == null) {
            return null;
        } else {
            return propValues.get(0);
        }
    }

    /**
     * Returns the list of values for the given property name. Note that these values are read-only.
     * Changes made to these values will not be persisted on putting the resource.
     *
     * @param key Key of the property.
     * @return List of values of the given property key.
     */
    @SuppressWarnings("unchecked")
    // We are certain that we have a list of strings in this case.
    public List<String> getPropertyValues(String key) {

        return (List<String>) properties.get(key);
    }

    /**
     * Returns all properties of the resource. Properties are stored as key (String) -> values
     * (List) pairs. It is not recommended to use this method to access properties. Instead, use
     * other property related Resource API methods provided.
     * <p/>
     * Note that these values are read-only. Changes made to these values will not be persisted on
     * putting the resource.
     *
     * @return All properties of the resource.
     */
    public Properties getProperties() {

        return properties;
    }

    /**
     * Remove property.
     *
     * @param key the property key.
     */
    public void removeProperty(String key) {

        removePropertyWithNoUpdate(key);
    }

    /**
     * Remove property without modifiying the resource.
     *
     * @param key the property key.
     */
    public void removePropertyWithNoUpdate(String key) {

        if (key != null) {
            properties.remove(key);
        }
    }

    /**
     * Remove property value.
     *
     * @param key   the property key.
     * @param value the property value.
     */
    public void removePropertyValue(String key, String value) {

        List<String> propValues = getPropertyValues(key);

        if (propValues != null) {
            propValues.remove(value);
        }
    }

    /**
     * Edit property value.
     *
     * @param key      the key.
     * @param oldValue the old value.
     * @param newValue the new value.
     */
    public void editPropertyValue(String key, String oldValue, String newValue) {

        List<String> propValues = getPropertyValues(key);

        if (propValues != null) {
            propValues.remove(oldValue);
            propValues.add(newValue);
        }
    }

    /**
     * Set a property with single value.
     *
     * @param key   the property key.
     * @param value the property value.
     */
    public void setProperty(String key, String value) {

        List<String> propValues = new ArrayList<String>();
        propValues.add(value);
        properties.put(key, propValues);
    }

    /**
     * Set a property with multiple value.
     *
     * @param key   the property key.
     * @param value the property values.
     */
    public void setProperty(String key, List<String> value) {

        setPropertyWithNoUpdate(key, value);
    }

    /**
     * Set a property with multiple value.
     *
     * @param key   the property key.
     * @param value the property values.
     */
    private void setPropertyWithNoUpdate(String key, List<String> value) {

        properties.put(key, value);
    }

    /**
     * Add a property value for the provided key. If there are values associated with the key, this
     * will add append value. If not this will create a new property value for the key.
     *
     * @param key   the property key.
     * @param value the property value.
     */
    public void addProperty(String key, String value) {

        addPropertyWithNoUpdate(key, value);
    }

    /**
     * Add a property value for the provided key. If there are values associated with the key, this
     * will add append value. If not this will create a new property value for the key. Here the
     * resource modified flag is not set.
     *
     * @param key   the property key.
     * @param value the property value.
     */
    public void addPropertyWithNoUpdate(String key, String value) {

        List<String> propValues = getPropertyValues(key);
        if (propValues != null) {
            // no need to check if the value is already there. we should permit adding repeating
            // values
            propValues.add(value);
        } else {
            propValues = new ArrayList<>();
            propValues.add(value);
            setPropertyWithNoUpdate(key, propValues);
        }
    }

    /**
     * Set properties.
     *
     * @param properties the properties.
     */
    public void setProperties(Properties properties) {

        if (properties != null) {
            this.properties = properties;
        }
    }

    /**
     * Method to get the db id of the content
     *
     * @return the db content id.
     */
    public int getDbBasedContentID() {

        return dbBasedContentID;
    }

    /**
     * Method to set the db id of the content.
     *
     * @param dbBasedContentID the db id of the content.
     */
    public void setDbBasedContentID(int dbBasedContentID) {

        this.dbBasedContentID = dbBasedContentID;
    }

    /**
     * Method to get the content stream.
     *
     * @return the content stream.
     * @throws LightRegistryException throws if the operation fail.
     */
    public InputStream getContentStream() throws LightRegistryException {

        if (content == null) {
            throw new LightRegistryException("Resource content is empty.");
        }

        if (content instanceof byte[]) {
            return new ByteArrayInputStream((byte[]) content);

        } else if (content instanceof String) {
            byte[] contentBytes = ((String) content).getBytes(StandardCharsets.UTF_8);
            return new ByteArrayInputStream(contentBytes);

        } else if (content instanceof InputStream) {
            return (InputStream) content;

        } else {
            throw new LightRegistryException(
                    "Cannot return input stream for content of type: " +
                            content.getClass().getName());
        }
    }

    /**
     * Method to get the content of the resource. If the resource is a collection this will return
     * an array of string that represent the paths of its children, otherwise it returns an byte
     * array or a string from the default resource implementation.
     *
     * @return the content.
     * @throws LightRegistryException throws if the operation fail.
     */
    public Object getContent() throws LightRegistryException {

        return content;
    }

    /**
     * Set the content of the resource.
     *
     * @param content the resource.
     * @throws LightRegistryException throws if the operation fail.
     */
    public void setContent(Object content) throws LightRegistryException {

        this.content = content;
    }

    /**
     * Prepare the resource content to be put.
     *
     * @throws LightRegistryException throws if the operation fail.
     */
    public void prepareContentForPut() throws LightRegistryException {

        if (content instanceof String) {
            content = RegistryUtils.encodeString((String) content);
        } else if (content instanceof InputStream) {
            content = RegistryUtils.getByteArray((InputStream) content);
        }
    }

    /**
     * Format the path to the standard way.
     *
     * @param path the path.
     * @return the formatted path.
     */
    private String preparePath(String path) {

        String preparedPath = path;

        // make sure that the path does not end with a "/"
        if (!path.equals(LightRegistryConstants.ROOT_PATH) &&
                path.endsWith(LightRegistryConstants.PATH_SEPARATOR)) {
            preparedPath =
                    path.substring(0, path.length() - LightRegistryConstants.PATH_SEPARATOR.length());
        }

        return preparedPath;
    }

    /**
     * Method to get the last updated username.
     *
     * @return the last updated username.
     */
    public String getLastUpdaterUserName() {

        return lastUpdaterUserName;
    }

    /**
     * Method to set the last updater username.
     *
     * @param lastUpdaterUserName the last updater username.
     */
    public void setLastUpdaterUserName(String lastUpdaterUserName) {

        this.lastUpdaterUserName = lastUpdaterUserName;
    }

    /**
     * Check whether there are any changes that need to make a version
     *
     * @return true, if there are version-able changes, false otherwise.
     */
    public boolean isVersionableChange() {

        return versionableChange;
    }

    /**
     * Method to set whether there are any changes that need to make a version
     *
     * @param versionableChange whether version-able change is made or not.
     */
    public void setVersionableChange(boolean versionableChange) {

        setLastModified(new Date());
        this.versionableChange = versionableChange;
    }

    /**
     * Get the path id.
     *
     * @return the path id.
     */
    public int getPathID() {

        return pathID;
    }

    /**
     * Set path id.
     *
     * @param pathID the path id.
     */
    public void setPathID(int pathID) {

        this.pathID = pathID;
    }

    /**
     * Get the resource name.
     *
     * @return the resource name.
     */
    public String getName() {

        return name;
    }

    /**
     * Method to set the name.
     *
     * @param name the name.
     */
    public void setName(String name) {

        this.name = name;
    }

    /**
     * Get the resource id implementation instance.
     *
     * @return the resource id.
     */
    public ResourceID getResourceID() {

        ResourceID resourceId = new ResourceID();
        resourceId.setCollection(this instanceof CollectionImpl);
        resourceId.setPathID(pathID);
        if (name == null && !(this instanceof CollectionImpl)) {
            name = RegistryUtils.getResourceName(path);
        }
        resourceId.setResourceName(name);
        resourceId.setPath(path);

        return resourceId;
    }
}
