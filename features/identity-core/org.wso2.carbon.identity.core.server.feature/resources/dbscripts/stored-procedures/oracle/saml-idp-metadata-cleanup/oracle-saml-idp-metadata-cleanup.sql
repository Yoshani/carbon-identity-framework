-- NOTE: This procedure assumes that the SAML IDP metadata is stored under the path
-- '/_system/governance/repository/identity/provider/saml' in the registry and only two corresponding RESOURCE entries
-- (one for the collection and one for the resource object) and one CONTENT entry exist for each SAML IDP metadata file.

CREATE OR REPLACE PROCEDURE WSO2_SAML_IDP_METADATA_CLEANUP AS

    -- ------------------------------------------
    -- DECLARE VARIABLES
    -- ------------------------------------------
    batchCount INT := 1;
    chunkCount INT := 1;
    rowCount INT   := 0;

    -- ------------------------------------------
    -- CONFIGURABLE VARIABLES
    -- ------------------------------------------
    batchSize INT        := 10000; -- SET BATCH SIZE FOR AVOID TABLE LOCKS [DEFAULT : 10000]
    chunkSize INT        := 500000; -- CHUNK WISE DELETE FOR LARGE TABLES [DEFAULT : 500000]
    enableLog BOOLEAN    := TRUE; -- ENABLE LOGGING [DEFAULT : TRUE]
    backupTables BOOLEAN := TRUE; -- SET IF REGISTRY TABLES NEEDS TO BE BACKED-UP BEFORE DELETE [DEFAULT : TRUE]

BEGIN

    IF (enableLog)
    THEN
        DBMS_OUTPUT.PUT_LINE('WSO2_SAML_IDP_METADATA_CLEANUP() STARTED...!');
    END IF;

    -- ------------------------------------------
    -- GET PATH ID LIST TO DELETE
    -- ------------------------------------------
    EXECUTE IMMEDIATE 'CREATE GLOBAL TEMPORARY TABLE RootPathIdList (ROOT_PATH_ID INT) ON COMMIT DELETE ROWS';
    INSERT INTO RootPathIdList (ROOT_PATH_ID) SELECT REG_PATH_ID FROM REG_PATH WHERE
     REG_PATH_VALUE = '/_system/governance/repository/identity/provider/saml';

    EXECUTE IMMEDIATE 'CREATE GLOBAL TEMPORARY TABLE PathIdList (REG_PATH_ID INT) ON COMMIT DELETE ROWS';
    INSERT INTO PathIdList (REG_PATH_ID) SELECT REG_PATH_ID FROM REG_PATH WHERE REG_PATH_PARENT_ID IN
     (SELECT ROOT_PATH_ID FROM RootPathIdList);

    -- ------------------------------------------
    -- BACKUP DATA
    -- ------------------------------------------
    IF (backupTables)
    THEN
        IF (enableLog)
        THEN
            DBMS_OUTPUT.PUT_LINE('TABLE BACKUP STARTED ... !');
        END IF;

        IF EXISTS (SELECT 1 FROM USER_TABLES WHERE TABLE_NAME = 'BAK_REG_RESOURCE')
        THEN
            IF (enableLog)
            THEN
                DBMS_OUTPUT.PUT_LINE('DELETING OLD BACKUP...');
            END IF;
            EXECUTE IMMEDIATE 'DROP TABLE BAK_REG_RESOURCE';
            EXECUTE IMMEDIATE 'DROP TABLE BAK_REG_CONTENT';
        END IF;

        -- BACKUP REG_RESOURCE TABLE
        EXECUTE IMMEDIATE 'CREATE TABLE BAK_REG_RESOURCE AS SELECT * FROM REG_RESOURCE WHERE REG_PATH_ID IN (SELECT REG_PATH_ID FROM PathIdList)';

        -- BACKUP REG_CONTENT TABLE
        EXECUTE IMMEDIATE 'CREATE GLOBAL TEMPORARY TABLE ContentIdList (REG_CONTENT_ID INT) ON COMMIT DELETE ROWS';
        INSERT INTO ContentIdList (REG_CONTENT_ID) SELECT DISTINCT REG_CONTENT_ID FROM BAK_REG_RESOURCE WHERE REG_CONTENT_ID IS NOT NULL;
        EXECUTE IMMEDIATE 'CREATE TABLE BAK_REG_CONTENT AS SELECT * FROM REG_CONTENT WHERE REG_CONTENT_ID IN (SELECT REG_CONTENT_ID FROM ContentIdList)';
    END IF;

    -- ------------------------------------------
    -- CLEANUP DATA
    -- ------------------------------------------

    WHILE chunkCount > 0
    LOOP
        -- CREATE CHUNK TABLE
        BEGIN
            EXECUTE IMMEDIATE 'DROP TABLE REG_RESOURCE_CHUNK_TMP';
            EXECUTE IMMEDIATE 'DROP TABLE REG_CONTENT_CHUNK_TMP';
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        EXECUTE IMMEDIATE 'CREATE TABLE REG_RESOURCE_CHUNK_TMP (REG_VERSION INT, REG_TENANT_ID INT, REG_CONTENT_ID INT)';
        EXECUTE IMMEDIATE 'CREATE TABLE REG_CONTENT_CHUNK_TMP (REG_CONTENT_ID INT)';

        INSERT INTO REG_RESOURCE_CHUNK_TMP (REG_VERSION, REG_TENANT_ID, REG_CONTENT_ID) SELECT REG_VERSION,
         REG_TENANT_ID, REG_CONTENT_ID FROM REG_RESOURCE WHERE REG_PATH_ID IN (SELECT REG_PATH_ID FROM PathIdList)
         AND ROWNUM <= chunkSize;
        chunkCount:= SQL%ROWCOUNT;
        INSERT INTO REG_CONTENT_CHUNK_TMP(REG_CONTENT_ID) SELECT REG_CONTENT_ID FROM REG_RESOURCE_CHUNK_TMP
         WHERE REG_CONTENT_ID IS NOT NULL;

        IF chunkCount = 0
        THEN
            EXIT;
        END IF;

        EXECUTE IMMEDIATE 'CREATE INDEX IDX_REG_RESOURCE_CHUNK_TMP ON REG_RESOURCE_CHUNK_TMP (REG_VERSION, REG_TENANT_ID, REG_CONTENT_ID)';
        EXECUTE IMMEDIATE 'CREATE INDEX IDX_REG_CONTENT_CHUNK_TMP ON REG_CONTENT_CHUNK_TMP (REG_CONTENT_ID)';;

        IF (enableLog)
        THEN
            DBMS_OUTPUT.PUT_LINE('CREATED REG_RESOURCE_CHUNK_TMP...');
        END IF;

        -- BATCH LOOP
        batchCount := 1;
        WHILE (batchCount > 0)
        LOOP
            -- CREATE BATCH TABLE
            BEGIN
                EXECUTE IMMEDIATE 'DROP TABLE REG_RESOURCE_BATCH_TMP';
                EXECUTE IMMEDIATE 'DROP TABLE REG_CONTENT_BATCH_TMP';
            EXCEPTION
                WHEN OTHERS THEN NULL;
            END;

            EXECUTE IMMEDIATE 'CREATE TABLE REG_RESOURCE_BATCH_TMP (REG_VERSION INT, REG_TENANT_ID INT, REG_CONTENT_ID INT)';
            EXECUTE IMMEDIATE 'CREATE TABLE REG_CONTENT_BATCH_TMP (REG_CONTENT_ID INT)';

            INSERT INTO REG_RESOURCE_BATCH_TMP (REG_VERSION, REG_TENANT_ID, REG_CONTENT_ID) SELECT REG_VERSION,
             REG_TENANT_ID, REG_CONTENT_ID FROM REG_RESOURCE_CHUNK_TMP WHERE ROWNUM <= batchSize;
            batchCount:= SQL%ROWCOUNT;
            INSERT INTO REG_CONTENT_BATCH_TMP(REG_CONTENT_ID) SELECT REG_CONTENT_ID FROM REG_RESOURCE_BATCH_TMP
             WHERE REG_CONTENT_ID IS NOT NULL;

            IF batchCount = 0
            THEN
                EXIT;
            END IF;

            EXECUTE IMMEDIATE 'CREATE INDEX IDX_REG_RESOURCE_BATCH_TMP ON REG_RESOURCE_BATCH_TMP (REG_VERSION, REG_TENANT_ID)';
            EXECUTE IMMEDIATE 'CREATE INDEX IDX_REG_CONTENT_BATCH_TMP ON REG_CONTENT_BATCH_TMP (REG_CONTENT_ID)';

            IF (enableLog)
            THEN
                DBMS_OUTPUT.PUT_LINE('CREATED REG_RESOURCE_BATCH_TMP...');
            END IF;

            -- BATCH DELETION
            IF (enableLog)
            THEN
                DBMS_OUTPUT.PUT_LINE('BATCH DELETE STARTED ON REG_RESOURCE...');
            END IF;

            DELETE FROM REG_RESOURCE WHERE (REG_VERSION, REG_TENANT_ID) IN (SELECT REG_VERSION, REG_TENANT_ID FROM
             REG_RESOURCE_BATCH_TMP);
            rowCount:= SQL%ROWCOUNT;
            DELETE FROM REG_CONTENT WHERE REG_CONTENT_ID IN (SELECT REG_CONTENT_ID FROM REG_CONTENT_BATCH_TMP);

            IF (enableLog)
            THEN
                DBMS_OUTPUT.PUT_LINE('BATCH DELETE FINISHED ON REG_RESOURCE : ' || rowCount);
            END;

            -- DELETE FROM CHUNK
            DELETE FROM REG_RESOURCE_CHUNK_TMP WHERE (REG_VERSION, REG_TENANT_ID) IN (SELECT REG_VERSION, REG_TENANT_ID
             FROM REG_RESOURCE_BATCH_TMP);
        END LOOP;
    END LOOP;

    -- DELETE TEMP TABLES
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE REG_RESOURCE_BATCH_TMP';
        EXECUTE IMMEDIATE 'DROP TABLE REG_CONTENT_BATCH_TMP';
        EXECUTE IMMEDIATE 'DROP TABLE REG_RESOURCE_CHUNK_TMP';
        EXECUTE IMMEDIATE 'DROP TABLE REG_CONTENT_CHUNK_TMP';
    EXCEPTION
        WHEN OTHERS THEN NULL;
    END;

    COMMIT;

    IF (enableLog)
    THEN
        DBMS_OUTPUT.PUT_LINE('CLEANUP COMPLETED...!');
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('ERROR OCCURRED: ' || SQLERRM);
END;
